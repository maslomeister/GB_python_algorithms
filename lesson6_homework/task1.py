# 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков. 
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# b. написать 3 варианта кода (один у вас уже есть);
# проанализировать 3 варианта и выбрать оптимальный;

# c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом. 
# Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# d. написать общий вывод: какой из трёх вариантов лучше и почему.
# Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной, 
# а проявили творчество, фантазию и создали универсальный код для замера памяти.


import random
import sys
import time
from collections import namedtuple, OrderedDict
import math

##################################################################################################
# Разбор задачи 4 из урока 3
# Определить, какое число в массиве встречается чаще всего
##################################################################################################


def convert_size(size_bytes):
    if size_bytes == 0:
        return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return "%s %s" % (s, size_name[i])


def performance_results(data):

    for item in data:
        print(
            f"\n{item[0]} версия программы потратила {convert_size(item[-2])} памяти и выполнилась за {item[-1]} секунд, её результат: {item[1]} раз встретилось число {item[2]}")

    print("")


def calc_size(variable, level=0):

    size = sys.getsizeof(variable)

    # print("\t" * level,
    # f"type= {variable.__class__}, size= {sys.getsizeof(variable)}, object= {variable}")
    if hasattr(variable, "__iter__"):
        if hasattr(variable, "items"):
            for key, val in variable.items():
                size += calc_size(key, level + 1)
                size += calc_size(val, level + 1)
        elif not isinstance(variable, str):
            for item in variable:
                size += calc_size(item, level + 1)
    return size


def calc_all(variables):
    total_size = 0
    for var in variables.keys():
        total_size += calc_size(variables.get(var))
    return total_size


##################################################################################################
# Реализация 1 с использованием вложенного цикла
##################################################################################################


def version1(array):

    start_time = time.process_time()

    num = array[0]
    max_amount = 1

    for i in range(len(array) - 1):

        amount = 1

        for j in range(i+1, len(array)):

            if array[i] == array[j]:

                amount += 1

            if amount > max_amount:

                max_amount = amount
                num = array[i]

    finish_time = time.process_time() - start_time

    ##################################################################################################
    locals_copy = locals().copy()

    # locals() возвращает таблицу локальных переменных в вызванном контексте,
    # вызвав её здесь мы получим словарь содержащий все инициализированные переменные
    # вплоть до вызова locals(), после чего мы копируем этот словарь в другую переменную и работаем с копией,
    # т.к. любой дальнейший вызов locals() в процессе подсчета переменных изменит словарь, что вызовет RuntimeError

    if max_amount > 1:
        return [num, max_amount, calc_all(locals_copy), finish_time]
    else:
        return [0, 0, 0, 0]


##################################################################################################
# Реализация 2 без использования вложенного цикла
##################################################################################################


def version2(array):

    start_time = time.process_time()

    max_amount = 0
    num = 0

    for i in array:
        amount = array.count(i)
        if(amount > max_amount):
            max_amount = amount
            num = i

    finish_time = time.process_time() - start_time

    ##################################################################################################
    locals_copy = locals().copy()
    # locals() возвращает таблицу локальных переменных в вызванном контексте,
    # вызвав её здесь мы получим словарь содержащий все инициализированные переменные
    # вплоть до вызова locals(), после чего мы копируем этот словарь в другую переменную и работаем с копией,
    # т.к. любой дальнейший вызов locals() в процессе подсчета переменных изменит словарь, что вызовет RuntimeError

    return [num, max_amount, calc_all(locals_copy), finish_time]


##################################################################################################
# Реализация 3 со словарем
##################################################################################################


def version3(array):

    start_time = time.process_time()

    diction = {}

    for item in array:
        if item in diction.keys():
            diction[item] += 1
        else:
            diction[item] = 1

    val = list(diction.values())
    key = list(diction.keys())

    finish_time = time.process_time() - start_time

    ##################################################################################################
    locals_copy = locals().copy()
    # locals() возвращает таблицу локальных переменных в вызванном контексте,
    # вызвав её здесь мы получим словарь содержащий все инициализированные переменные
    # вплоть до вызова locals(), после чего мы копируем этот словарь в другую переменную и работаем с копией,
    # т.к. любой дальнейший вызов locals() в процессе подсчета переменных изменит словарь, что вызовет RuntimeError

    return [key[val.index(max(val))], diction[key[val.index(max(val))]], calc_all(locals_copy), finish_time]


print(
    "\nПрограмма опредялет какой элемент списка встречается чащего всего 3 разными способами"
    + "\nНа ввод принимаются только целые числа"
    + "\nПри вводе чисел меньше 20 000 программа выполняется достаточно быстро"
    + "\nПри вводе чисел больше 50 000 и меньше 200 000 программа может выполняться достаточно долго"
    + "\nЕсли ввести число >= 100 000, выполнятся только вторая и третья версии программы для сохранения времени"
    + "\nЕсли ввести число >= 200 000 выполнится только третья версия программы")

input_size = int(input("\nУкажите размер входного массива: "))


##################################################################################################
# Создаем список и наполняем его случайными значениями в диапазоне от 0 до input_size // 1.5
##################################################################################################
array = [random.randint(0, input_size // 1.5) for _ in range(input_size)]

##################################################################################################
# Выполняем функции и заносим результаты в список
##################################################################################################
if input_size >= 200000:
    results = [["3"] + version3(array)]
elif input_size >= 100000:
    results = [["2"] + version2(array), ["3"] + version3(array)]
else:
    results = [["1"] + version1(array), ["2"] +
               version2(array), ["3"] + version3(array)]


##################################################################################################
# Выводим в консоль затраченную память, скорость выполнения и полученный результат для каждой версии программы
##################################################################################################

performance_results(results)


##################################################################################################
# Результаты выполнения для разных размеров входного списка
##################################################################################################
# Укажите размер входного массива: 900

# 1 версия программы потратила 32.57 KB памяти и выполнилась за 0.03125 секунд, её результат: 548 раз встретилось число 6

# 2 версия программы потратила 32.55 KB памяти и выполнилась за 0.015625 секунд, её результат: 548 раз встретилось число 6

# 3 версия программы потратила 108.53 KB памяти и выполнилась за 0.0 секунд, её результат: 548 раз встретилось число 6

##################################################################################################
# Укажите размер входного массива: 40000

# 1 версия программы потратила 1.37 MB памяти и выполнилась за 61.484375 секунд, её результат: 18724 раз встретилось число 8

# 2 версия программы потратила 1.37 MB памяти и выполнилась за 16.140625 секунд, её результат: 18724 раз встретилось число 8

# 3 версия программы потратила 4.46 MB памяти и выполнилась за 0.015625 секунд, её результат: 18724 раз встретилось число 8

##################################################################################################
# Укажите размер входного массива: 99000

# 1 версия программы потратила 3.43 MB памяти и выполнилась за 375.234375 секунд, её результат: 19183 раз встретилось число 9

# 2 версия программы потратила 3.43 MB памяти и выполнилась за 99.15625 секунд, её результат: 19183 раз встретилось число 9

# 3 версия программы потратила 12.19 MB памяти и выполнилась за 0.015625 секунд, её результат: 19183 раз встретилось число 9

##################################################################################################
# Укажите размер входного массива: 199000

# 2 версия программы потратила 6.91 MB памяти и выполнилась за 403.140625 секунд, её результат: 130666 раз встретилось число 10

# 3 версия программы потратила 24.48 MB памяти и выполнилась за 0.046875 секунд, её результат: 130666 раз встретилось число 10

##################################################################################################
# Укажите размер входного массива: 500000

# 3 версия программы потратила 59.07 MB памяти и выполнилась за 0.109375 секунд, её результат: 117675 раз встретилось число 10

##################################################################################################
# Укажите размер входного массива: 1500000

# 3 версия программы потратила 186.76 MB памяти и выполнилась за 0.375 секунд, её результат: 860141 раз встретилось число 10

##################################################################################################
# Вывод:
#
# первый вариант работает плохо почти на любых значениях, он тратит мало памяти, но выполняется
# очень долго
#
# на значениях до ~10000 себя хорошо показывает второй вариант, выполняясь за небольшое количество времени
# и тратя мало памяти
#
# третий вариант показал себя лучше всех, он выполняется в разы быстрее как первого, так и второго варианта,
# на таких же размерах входного списка, но тратит в несколько раз больше памяти. На мелких значениях
# такое потребление памяти не является проблемой, но на очень больших размерах входного списках
# этот вариант будет забирать очень много памяти
##################################################################################################
